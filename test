リストビュー

    データを表示する場合、TextBoxに表示しても良いが、大量のデータを扱うのは難しい。
        Excelのように、項目と行で管理するのが、ListView。 
    ListViewは、基本的にはListBoxのように行のデータをItemとして管理する。
        列のデータはSubItemとして管理されている。 
    通常のリストビューでは、項目名の追加→行の追加→データの設定というようになる。
        後述する仮想リストビューでは、項目名の追加と行数の指定のみで、データの管理は自分で行う必要がある。
            その場合、行の追加やデータのセットについては、以下のルーチンは使用しない。 

項目名を追加

    まず最初に項目名を作成する。ListView_InsertColumnというマクロを使用する。
        以下は項目名追加用ルーチンの例。 

void InsColumn(HWND hWnd, char *str, int cx, int iSub)
{
        LV_COLUMN col;

        col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        col.fmt = LVCFMT_LEFT;
        col.cx = cx;
        col.pszText = str;
        col.iSubItem = iSub;
        ListView_InsertColumn(hWnd, iSub, &col);
        return;
}

    hWnd：リストハンドル、str：項目名、cx：項目の幅、iSub：項目番号（0〜）

行の追加

    次に、行を追加する。これはListView_InsertItemマクロを使用。
        この例では一番左端のカラムにデータが追加される。データを空にすれば行の追加だけになる。 

void InsItem(HWND hWnd, int item, char *str)
{
        LV_ITEM itm;

        itm.mask = LVIF_TEXT;
        itm.pszText = str;
        itm.iItem = item;
        itm.iSubItem = 0;
        ListView_InsertItem(hWnd, &itm);
        return;
}

データのセット

    最後にデータをセットする。これもListViwe_SetItemマクロを使用する。

void SetSubitem(HWND hWnd, int item, int subitem, char *str)
{
        LV_ITEM itm;

        itm.mask = LVIF_TEXT;
        itm.pszText = str;
        itm.iItem = item;
        itm.iSubItem = subitem;

        ListView_SetItem(hWnd, &itm);
        return;
}

リストビューの削除

    リストビューを作り直す時等は、以下のように全カラムを削除してから、新規にカラムを作る。

void listview_delallcol(HWND hlistview)
{
        int i,count;

        //カラム数を求める
        count = Header_GetItemCount(ListView_GetHeader(hlistview));

        for (i=0; i<count ;i++) {
                ListView_DeleteColumn(hlistview,0);
        }
}

    あと、ListView_DeleteAllItemsというマクロもあるみたいだけど、使ったことはない。

カスタムドロー

    標準のListViewの特定の行や列に色を指定することは出来ないが、
        WindowのWM_NOTIFYメッセージでは、描画前のシーケンスCDDS_PREPAINTイベントを拾うことが出来る。 
    ここで、CDRF_NOTYFYITEMDRAWでITEM描画情報をリクエストすると、
        ListViewのITEMを描画する直前に、CDDS_ITEMPREPAINTイベントも受けられるようになる。 
    ITEMPREPAINTでTextの色を設定すれば、LisViewの行毎の色の変更が可能になる。(nmcd.dwItemSpecが行番号)
        ここでさらに、CDRF_NOTIFYSUBITEMDRAWでSUBITEM描画情報をリクエストすると、SUBITEM描画直前のイベントが受けられる。 
    これは、CDDS_ITEMPREPAINT|CDDS_SUBITEMが結合したイベントとして拾えるので、
        この時、TEXTの色を設定すれば、ListViewの列毎の色の変更も可能になる。(iSubItemが列番号) 

    具体的には、以下のようにすれば良い。（以下はDialog中のコントロールでの例）

    case WM_NOTIFY:
            LPNMHDR lpnmhdr;
            LPNMLVCUSTOMDRAW lplvcd;

            lpnmhdr = (LPNMHDR)lp;
            if (lpnmhdr->hwndFrom == g.hbtable) {   // BINTABLEからのメッセージであることをチェック
                    switch ( lpnmhdr->code ) {
                    case NM_CUSTOMDRAW :
                    // ---- カスタムドローで、Listviewの色を設定。
                            lplvcd = (LPNMLVCUSTOMDRAW)lp;
                            switch (lplvcd->nmcd.dwDrawStage) {

                            case CDDS_PREPAINT:     // 描画前にITEM情報をリクエスト
                                    SetWindowLong(hWnd,DWL_MSGRESULT,(long)CDRF_NOTIFYITEMDRAW);
                                    return TRUE;
                            case CDDS_ITEMPREPAINT: // ITEM描画前にSUBITEM情報をリクエスト
                                    SetWindowLong(hWnd,DWL_MSGRESULT,(long)CDRF_NOTIFYSUBITEMDRAW);
                                    return TRUE;
                            case CDDS_ITEMPREPAINT|CDDS_SUBITEM:    // SUBITEM描画イベント
                                    row = lplvcd->nmcd.dwItemSpec;  // 行番号
                                    col = lplvcd->iSubItem;         // 列番号
                                    ListView_GetItemText(g.hbtable,row,col,line,255);
                                    i = atoi(line)*10%256;
                                    lplvcd->clrTextBk = RGB(255,255-i,255-i);       //値により色を設定
                                    lplvcd->clrText = RGB(0, 0, 0);
                                    SetWindowLong(hWnd,DWL_MSGRESULT,(long)CDRF_NEWFONT);
                                    return TRUE;
                            }
                            break;
                    default :
                            break;
                    }       // end of switch(lpnmhdr->code)
            }       // end of (hwndFrom == g.hbtable) 

            return TRUE;

カスタムドローは最初はうまく行かなかった。自分が引っ掛かったのは以下のようなこと。

    Windowと、DialogではCDRF_NOTIFYITEMDRAWやCDRF_NEWFONTの渡し方2が違う。
        Windowでは、単にreturnの引数で返せば良いが、DialogではSetWindowLongで渡して、return TRUEする必要がある。 
    SUBITEMの描画情報の条件は、lplvcd->nmcd.dwDrawStage==CDDS_ITEMPREPAINT|CDDS_SUBITEMであって、
        lplvcd->nmcd.dwDrawStage==CDDS_ITEMPREPAINT || lplvcd->nmcd.dwDrawStage==CDDS_SUBITEMではない。 

仮想リストビュー

    ListViewは便利だが、あまり大量のデータを扱うように出来ていない。
        項目数が多いと、動作が極端に遅くなってしまう。
        元々、データテーブルを持っている場合には、リストビューにコピーする手間も掛かる。 
    データの保持はプログラマに任せて、項目数の管理と表示のみ行うのが、仮想リストビュー。
        表示する項目のデータを、都度要求して表示するだけなので、高速。 

手順としては、

    まずListViewのリソースプロパティで、OwnerDataをTrueにしておく。
        これでデータ保持はプログラマに任せることになる 
    項目名を追加する。これは通常のListViewと同じ。
    次に、以下のようにデータの行数（アイテム数）を指定する。

            ListView_SetItemCountEx( g.hbtable, 9999, LVSICF_NOINVALIDATEALL );

    あとは、WindowのWM_NOTIFYメッセージで、LVN_GETDISPINFOイベントを拾って、
        指定された行,列のデータをpszTextに返せば良い。(iSubItem:列番号、iItem:行番号) 

case WM_NOTIFY:
        LPNMHDR lpnmhdr;
        lpnmhdr = (LPNMHDR)lp;

        if (lpnmhdr->hwndFrom == g.hbtable) {   // BINTABLEからのメッセージであることをチェック
                switch ( lpnmhdr->code ) {
                case LVN_GETDISPINFO :

                        LV_DISPINFO *pLvDispInfo;
                        pLvDispInfo = (LV_DISPINFO*)lp;
                        TCHAR szString[MAX_PATH];
        
                        if (pLvDispInfo->item.mask & LVIF_TEXT) {       // TEXTならば
                                col = pLvDispInfo->item.iSubItem;       // 列番号
                                row = pLvDispInfo->item.iItem;          // 行番号

                                wsprintf(szString,"%d,%d",col,row);     // とりあえず列行を出力
                                if (lstrlen(szString) < pLvDispInfo->item.cchTextMax)
                                        lstrcpy(pLvDispInfo->item.pszText,szString);
                                else
                                        lstrcpy(pLvDispInfo->item.pszText,_T(""));
                        }
                        break;
                default :
                        break;
                }       // end of switch(lpnmhdr->code)
        }       // end of (hwndFrom == g.hbtable) 

        return TRUE;

    TEXTならば、item.maskがLVIF_TEXTの場合だけ処理する。
        データは自分で管理するので、ListViewのデータの設定や保存も自前で行う必要がある。
        そのため、ListViwe_SetItemマクロによる、行の追加やデータの設定は行わない。 
    実際に表示するデータしか読書きしないので、巨大なデータでも高速。
        データをファイルから読んだり、自動設定しても良いので自由度が高く、小さなデータでもメリットが大きいと思う。 
    前述のカスタムドローと組み合わせて使用することも出来る。

オーナードロー

    背景色や、フォントの変更ぐらいならば、カスタムドローが簡単。
        全て自分で描画してしまうのを、オーナードローと言う。 

    手順としては、まずListViewのリソースプロパティで、OwnerDrawFixedをTrueにしておく
        これでデータ表示はプログラマに任されることになる
        具体的には、これでWM_DRAWITEMイベントが発生するようになるので、これを捕まえて表示すれば良い。 

    オーナードローによるItem表示の例

                    ：

            case WM_DRAWITEM:                       // オーナードロー
                    DrawListItem((LPDRAWITEMSTRUCT)lp);
                    return TRUE;

                    ：

    void DrawListItem(LPDRAWITEMSTRUCT lpDraw)
    {
            HWND            hList;                  //リストビューのハンドル
            HDC             hdc;                    //デバイスコンテキスト
            RECT            rt;     
            HBRUSH          hBrush;                 //背景描画用のブラシ
            LVCOLUMN        LvColumn;               //列項目取得用の構造体
            int             SubItemNum;
            int             SubItem;
            str255          Text;

            hList=lpDraw->hwndItem;
            hdc = lpDraw->hDC;

            SaveDC(hdc);                            // デバイスコンテキスト保存
            SetTextColor(hdc, RGB(0,0,255));        // 文字色を設定

            //カラムヘッダ情報取得用
            ZeroMemory(&LvColumn,sizeof(LvColumn));
            LvColumn.mask=LVCF_FMT;

            //列の数を取得する
            SubItemNum=Header_GetItemCount(ListView_GetHeader(hList))-1;
            //SubItemの表示
            for (SubItem=0; SubItem<=SubItemNum ;SubItem++) {
                    //SubItemの大きさを取得
                    ListView_GetSubItemRect(hList,lpDraw->itemID,SubItem,LVIR_BOUNDS,&rt);
                    //カラムヘッダの情報取得
                    ListView_GetColumn(hList,SubItem,&LvColumn);
                    ListView_GetSubItemRect(hList,lpDraw->itemID,SubItem,LVIR_LABEL,&rt);
                    //アイテムの文字情報を取得
                    ListView_GetItemText(hList,lpDraw->itemID,SubItem,Text,sizeof(Text));
                    //背景色の塗潰し
                    hBrush = CreateSolidBrush(RGB((atoi(Text)%256)*10,0,0));
                    FillRect(hdc,&rt,hBrush);
                    DeleteObject( hBrush );          // 作成したブラシを廃棄
                    // SubItemを表示
                    DrawListItemText(hdc,Text,&rt,LvColumn.fmt);
            }

            //デバイスコンテキストを復帰
            RestoreDC(hdc,-1);
    }

    上記の例は単なる文字列表示のみで、選択時の処理等は省略している。

Click位置のチェック

    以下はクリックされた位置をチェックする例

    LV_HITTESTINFO lvinfo;
    LV_ITEM item;
    str255  buf;

    ：

    // WN_NOTIFYのLVN_ITEMCHANGED等の処理

    GetCursorPos((LPPOINT)&lvinfo.pt);
    ScreenToClient(((LPNMLISTVIEW)lp)->hdr.hwndFrom, &lvinfo.pt);
    ListView_HitTest(((LPNMLISTVIEW)lp)->hdr.hwndFrom, &lvinfo);
    if ((lvinfo.flags & LVHT_ONITEM) != 0) {
            item.mask = TVIF_HANDLE | TVIF_TEXT;
            item.iItem = lvinfo.iItem;
            item.iSubItem = 0;          // サブアイテム番号
            item.pszText = buf;         // テキストバッファ
            item.cchTextMax = 255;  // バッファ容量
            ListView_GetItem(((LPNMLISTVIEW)lp)->hdr.hwndFrom, &item);
            MessageBox(hWnd, buf,"Click", MB_OK);
    }

    この例では、カーソルキーで移動した場合も最初のクリック位置しか分からない。
        でも、ListView上にチェックボックス等を置きたい場合等に使える。 

行の選択

    ListViewの指定した行（n）の選択・非選択

            ListView_SetItemState(g.hList, n, LVIS_SELECTED, LVIS_SELECTED)

            ListView_SetItemState(g.hList, n, 0, LVIS_SELECTED)

    全選択・全非選択（-1を指定すると全指定となる）

            ListView_SetItemState(g.hList, -1, LVIS_SELECTED, LVIS_SELECTED)

            ListView_SetItemState(g.hList, -1, 0, LVIS_SELECTED)

選択行のチェック

    ListViewは、初期状態では複数選択可能なので、
        例えば以下のように、複数の選択行について処理する。

                data_n = ListView_GetItemCount(g.hList);
                for (i = 0; i < data_n; i++) {
                        if (ListView_GetItemState(g.hList, i,LVIS_SELECTED)) {

                                // 選択行の処理

                        }
                }

選択色の変更（未解決）

    ListViewのAlways Show SelectionをTrueにしない場合に限り、
        フォーカスが外れている場合の選択色は、カスタムドローで設定可能。

                        case WM_NOTIFY:
                                ：

                                case NM_CUSTOMDRAW:
                                        lplvcd = (LPNMLVCUSTOMDRAW)lp;
                                        switch (lplvcd->nmcd.dwDrawStage) {

                                        case CDDS_PREPAINT:     // 描画前にITEM情報をリクエスト
                                                SetWindowLong(hWnd, DWL_MSGRESULT, (long)CDRF_NOTIFYITEMDRAW);
                                                break;
                                        case CDDS_ITEMPREPAINT:
                                                row = lplvcd->nmcd.dwItemSpec;  // 行番号
                                                if (ListView_GetItemState(g.hList, row, LVIS_SELECTED)) {
                                                        lplvcd->clrTextBk = RGB(0, 255, 255);
                                                        lplvcd->clrText = RGB(0, 0, 0);
                                                        SetWindowLong(hWnd, DWL_MSGRESULT, (long)CDRF_NEWFONT);
                                                }
                                                break;
                                        }
                                        break;

    但し、ListViewにフォーカスされている場合の選択色を変える方法は分からなかった。
        こちらの方法でフォーカス時の選択色を無くすことが出来たが3結局、色設定は出来なかった。 

    とにかく、Always Show SelectionをONにして、フォーカスが外れたときの選択色が薄い灰色で物凄く見づらかったので、
            それだけでも設定できれば良いやということで、これ以上は追求しない。 

ListViewの再表示

    ListViewを描画無効領域に設定して、再描画させる。

    InvalidateRect(g.hList, NULL, TRUE);

ListViewの使い方の例

    ListViewの簡単な使い方の例。（VC5でも動作可能）
        仮想ListViewを使うので、Owner Dataを True に
        カラムを持っているので、Viewを Report にしておく
        項目名の設定には、前述のInsColumnルーチンを使用。

        DWORD dwStyleEx=0;
        NM_LISTVIEW *pNMLV;

        case WM_INITDIALOG:     // Dialogの初期設定

                // リストハンドルの取得
                g.hList = GetDlgItem(hWnd,IDC_REGLIST);

                // １行選択と罫線の表示
                dwStyleEx = ListView_GetExtendedListViewStyle( g.hList );
                dwStyleEx |= ( LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT | LVS_EX_ONECLICKACTIVATE);
        //      dwStyleEx |= ( LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT );
                ListView_SetExtendedListViewStyle( g.hList, dwStyleEx );

                // 項目名の設定
                InsColumn(g.hList,"名前",50,0);
                InsColumn(g.hList,"内容",200,1);
                InsColumn(g.hList,"設定",50,2);

                // 行数の設定（データ数に合わせて設定しておく）
                ListView_SetItemCountEx(g.hList, 9999, LVSICF_NOINVALIDATEALL );

                // とりあえず、１行目を選択状態にしておく
                ListView_SetItemState(g.hList,0,LVIS_FOCUSED|LVIS_SELECTED,LVIS_FOCUSED|LVIS_SELECTED);

        case WM_NOTIFY:
                LPNMHDR lpnmhdr;
                lpnmhdr = (LPNMHDR)lp;

                switch(((LPNMHDR)lp)->idFrom) {
                case IDC_REGLIST:

                        switch ( lpnmhdr->code ) {
                        case LVN_GETDISPINFO :  // 仮想ListViewの表示データ問合せ

                                LV_DISPINFO *pLvDispInfo;
                                pLvDispInfo = (LV_DISPINFO*)lp;
                                TCHAR szString[MAX_PATH];

                                if (pLvDispInfo->item.mask & LVIF_TEXT) {
                                        col = pLvDispInfo->item.iSubItem;       // 列番号
                                        row = pLvDispInfo->item.iItem;          // 行番号

                                        switch(col) {
                                        case 0:
                                                wsprintf(szString,"%s",d[row].name);    // 名前をセット
                                                break;
                                        case 1:
                                                wsprintf(szString,"%s",d[row].desc);    // 内容をセット
                                                break;
                                        case 2:
                                                wsprintf(szString,"%d",d[row].data);    // 設定値をセット
                                                break;
                                        }
                                        if (lstrlen(szString) < pLvDispInfo->item.cchTextMax)
                                                lstrcpy(pLvDispInfo->item.pszText,szString);    // 表示文字列を返す
                                        else
                                                lstrcpy(pLvDispInfo->item.pszText,_T("****"));  // 文字列が大きすぎる場合
                                }
                                break;
        //              case LVN_ITEMCHANGED:
                        case LVN_ITEMACTIVATE:
                                row = ListView_GetNextItem(g.hList,-1,LVIS_SELECTED);   // 選択行を求める
                                if (row!=-1)
                                        printf(">%d\n",row);
                                break;

                        case LVN_COLUMNCLICK:   // カラムヘッダ部のクリック
                                pNMLV = (NM_LISTVIEW *)lp;
                                printf(">col %d click\n",pNMLV->iSubItem);
                                break;

                        default :
                                break;
                        }
                }

        return TRUE;

    WM_NOTIFYイベントで、表示する行と列の内容を問い合わせてくるので、
        表示したい内容をセットすれば良い。 
    LVN_ITEMACTIVATEは、デフォルトでは２クリックでアクティブになるが、
        LVS_EX_ONECLICKACTIVATEをセットすることで、１クリックでアクティブになる。 
    試しに、これでクリックを検出するようにしてみたが、少し反応が鈍い気がする。
        普通に、LVN_ITEMCHANGEDや、NM_DBLCLICKイベントを使う方が良いかもしれない。 
    基本的にListViewは行単位の選択しかサポートしていない4ので、
        列方向の選択は、自前で何とかするしかなさそうだ。 

    ListViewの選択状態をプログラムで変更するには、ListView_SetItemStateを使う。
        ３番目のパラメータが設定するビットの指定で、４番目がマスク。
        例えば非選択状態にするためには、３番目に0を指定して、４番目にLVIS_SELECTEDを指定する。 

    VC5では、リソースViewでオーナーデータが設定出来ない（オーナーデータのチェックボックスが出ない）ので、仮想ListViewが使えないと思っていたけど、
        CreateWindowのスタイルで設定すれば、問題なく仮想リストビューが使える。 
    リソースViewでリソースを作成した後に、テキストエディタで、rcファイルを編集してLVS_OWNERDATAを追加しておけば、無問題。

        CONTROL         "List1",IDC_REGLIST,"SysListView32",LVS_REPORT | 
                        LVS_OWNERDATA | WS_BORDER | WS_TABSTOP,131,23,216,154

2CDDS_ITEMPREPAINTイベントが来ない場合はコレを疑うこと。
3フォーカスが何処だか分からなくなってしまった。
4ListViewの列方向は取って付けたような中途半端な仕様。初めから２次元を扱うように作ってあれば、すっきりしたのに。
